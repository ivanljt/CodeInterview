package t八大排序;

/**
 *
 * 思路：首先建立一个大顶堆或者小顶堆，每一轮中将堆顶的元素与当前最后的一个叶子节点交换，然后调整堆，保持堆序性。
 *
 * 如何建堆？假设我们要建立的是一个大顶堆，
 * 大顶堆的特性：任意一个节点都大于它的左右子节点（如果有的话）
 * 假设我们使用数组来存储堆节点的话
 * 父节点的下标是 0，那么左右叶子节点的下标分别为 1，2；
 * 父节点的下标是 1，那么左右叶子节点的下标分别为 3，4；
 * 父节点的下标是 2，那么左右叶子节点的下标分别为 3，4；
 * 推广（因为堆是一种完全二叉树）：当前节点下标为 i，那么 左子节点的下标为 2i+1 右子节点的下标为 2i+2
 *
 * 确定了父子节点下标关系之后，我们的问题就变成了如何对堆进行调整，维护堆序性
 * 上浮和下潜
 * */
class HeapSort {

}
